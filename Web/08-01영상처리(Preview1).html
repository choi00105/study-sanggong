<!DOCTYPE html>
<HTML>
    <HEAD>
        <style>
            
            body {
                margin-top: 80px;
                text-align: center;
                background-color: rgba(127, 127, 127, 0.6);
                overflow: hidden;
                -ms-user-select: none;
                -moz-user-select: -moz-none;
                -khtml-user-select: none;
                -webkit-user-select: none;
                user-select: none;
            }

            .title {
                margin: 10px 10px;
                font-size: 50px;
                font-weight: bold;
                font-style: italic;
                text-shadow: 2px 2px 2px white;
            }

            div > #lena {
                height: 64px;
                width: 64px;
                box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.4);
                transition-duration: 1s;

            }

            div > .arrow {
                font-size: 50px;
            }
            #mark {
                font-size: 50px;
                cursor: pointer;
            }
            .show { 
               display: inline-block; 
            }

            .hide { 
                display: none; 
            }
            #pray {
                font-size: 50px;
                cursor: pointer;

            }

            div > #lenaExample {
                height: 80px;
                box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.4);
                transition-duration: 1s;
            }
            #lena:hover {
                height: 160px;
                width: 160px;
            }
            #lenaExample:hover {
                height: 200px;
            }
            .container {
                justify-content: center;
                align-items: center;
                display: flex;
            }
            canvas {
                border: 8px double black;
                background-color: white;
                margin: 20px 5px;
                padding: 10px;
                box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.4);
            }

            #inCanvas, #outCanvas {
                height: 256px;
                width: 256px;
            }
            .bottom{
                margin: 30px 10px;
            }
            .bottom > p {
                font-size: 12px;
                text-align: left;
                color: gray;
            }
            a {
                text-decoration: none;
            }
            .stophv {
                pointer-events: none;
            }

        </style>
        <script lang="javascript">
            var inCanvas, inCtx, outCanvas, outCtx;
            var inImage, inH, inW;
            var outImage, outH, outW;
            var inPaper, outPaper;
            var inFile;

            // =============== 공통 함수부 
            
            function init() {
                inCanvas =document.getElementById("inCanvas"); // 도화지에 접근
                inCtx = inCanvas.getContext("2d"); // 물감 , 붓, 물통
                outCanvas =document.getElementById("outCanvas"); // 도화지에 접근
                outCtx = outCanvas.getContext("2d"); // 물감 , 붓, 물통
                inCtx.font = "30px NotoKR";
                inCtx.fillStyle = "rgb(0,0,0)";
                inCtx.fillText("사진을 선택해 주세요",5,90);
                outCtx.font = "30px gothic";
                outCtx.fillStyle = "rgb(0,0,0)";
                outCtx.fillText("여기 출력 됩니다",30,90);
                

            }
            function openRawImage() {
                // 선택한 RAW 데이터를 읽어서 처리하기
                inFile = document.getElementById('inFile').files[0]; //
                const fileExtension = inFile.name.split('.').pop(); // 파일 확장자 추출
                if (fileExtension !== 'raw') {
                    document.getElementById('inFile').value = ''; // 선택한 파일 이름 안뜨게
                    inFile = null;
                    alert('올바른 파일 확장자 파일을 선택해주세요\n(현재는 .raw 파일만 지원됩니다)');
                } else {
                // (중요 !) 이미지 폭과 높이를 계산
                inH = inW =  Math.floor(Math.sqrt(inFile.size));
                console.log(inFile.name, fileExtension);
                // 메모리 확보
                inImage = new Array(inH);
                for(var i = 0; i<inH; i++) {
                    inImage[i] = new Array(inW);
                }
                // 캔버스 크기 조절
                inCanvas.height =inH;
                inCanvas.width = inW;

                // RAW -> 메모리(배열)로 로딩
                var reader = new FileReader(); // 파일 객체
                reader.readAsBinaryString(inFile);
                reader.onload = function() {
                    var blob = reader.result; // 파일을 한 덩어리(blob)에 넣기
                    // blob에서 한점씩 (256 * 256) 뽑아서 2치원 배열에 넣기
                    for (var i = 0; i<inH; i++){
                        for (var k = 0; k<inH; k++){
                            var sPixel = (i*inH + k); // 시작 위치
                            var ePixel = (i*inH + k) + 1; // 끝 위치
                            inImage[i][k] = blob.slice(sPixel, ePixel).charCodeAt(0); // 한점만 썰어내기 & ex) '뺇' -> 253
                        }
                    }
                    displayImage();
                }
                outCtx.fillStyle = "rgb(0,0,0)";
                outCtx.fillRect(0, 30, 300, 100);
                
                outCtx.fillStyle = "rgb(255,255,255)";
                outCtx.fillText("알고리즘을 선택해",30,70);
                outCtx.fillText("주세요",100,110);
                }
            }

            function displayImage() {
                // 입력 메모리를 paper에 콕콕 찍기
                
                inPaper = inCtx.createImageData(inH, inW);
                    for (var i = 0; i<inH; i++){
                        for (var k = 0; k<inW; k++){
                            var px = inImage[i][k];
                            inPaper.data[(i*inH +k) *4 + 0] = px; // R
                            inPaper.data[(i*inH +k) *4 + 1] = px; // G
                            inPaper.data[(i*inH +k) *4 + 2] = px; // B
                            inPaper.data[(i*inH +k) *4 + 3] = 255; // Alpha
                        }
                    }
                inCtx.putImageData(inPaper, 0, 0);
                
                

                // 출력 메모리를 paper에 콕콕 찍기
                if(outH){
                outCanvas.height=outH;
                outCanvas.width=outW;
                outPaper = outCtx.createImageData(outH, outW);
                    for (var i = 0; i<outH; i++){
                        for (var k = 0; k<outW; k++){
                            var px = outImage[i][k];
                            outPaper.data[(i*outH +k) *4 + 0] = px; // R
                            outPaper.data[(i*outH +k) *4 + 1] = px; // G
                            outPaper.data[(i*outH +k) *4 + 2] = px; // B
                            outPaper.data[(i*outH +k) *4 + 3] = 255; // Alpha
                        }
                    }
                outCtx.putImageData(outPaper, 0, 0);
                }
            }

            function selectAlgo(selectNum) {
                console.log(inFile)
                if(inFile){
                switch(parseInt(selectNum.value)){
                    case 100: equl_image(); break;
                    case 101: add_image(); break;
                    case 102: reverse_image(); break;
                    case 103: mirror_image(); break;
                    case 104: vertical_flip(); break;
                    case 105: rotate_90_degrees(); break;
                    case 106: rotate_180_degrees(); break;
                    case 107: rotate_270_degrees(); break;
                    case 108: black_or_white(); break;
                    case 109: sharpening(); break;
                    case 110: bw_image(); break;
                    case 111: bw2_image(); break;
                    case 112: bw3_image(); break;

                    case 200: zoomOut_image(); break;
                    case 201: zoomIn_image(); break;
                    case 202: zoomIn2_image(); break;
                    case 210: rotate_image(); break;
                    case 211: rotate2_image(); break;

                    case 300: embos_image(); break;
                    case 301: blur_image(); break;
                    case 302: edge_image(); break;
                    case 303: laplacian_image(); break;
                    case 304: vertical_image(); break;

                    case 400: histoSt_image(); break;
                    case 401: endIn_image(); break;
                    case 402: histoEqual_image(); break;
                    
                }
            } else {
                    alert('파일을 먼저 선택 해주세요!');
                    document.getElementsByName('pixel')[0].value = 0;
                    inCtx.fillStyle = "white";
                    inCtx.fillRect(0, 0, inCanvas.width, inCanvas.height);
                    outCtx.fillStyle = "white";
                    outCtx.fillRect(30, 30, outCanvas.width, outCanvas.height);
                    inCtx.font = "35px NotoKR";
                    inCtx.fillStyle = ("red");
                    inCtx.fillText("사진 파일을 먼저",10,90);
                    outCtx.font = "35px gothic";
                    outCtx.fillStyle = ("rgb(0,0,0)");
                    outCtx.fillText("선택 해 주세요",30,90);
            }
        }

            // =============== 영상처리 함수부 ***
            function equl_image() {
                // (중요!) 출력 영상의 크기를 결정 -> 알고리즘에 따라 다름
                outH = inH;
                outW = inW;
                // 출력 이미지 할당
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                // ************* 진짜 영상처리 알고리즘 구현*************
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        outImage[i][k] = inImage[i][k];
                    }
                }
                // *****************************************
                displayImage();
            }

            function histoSt_image() {
                // (중요!) 출력 영상의 크기를 결정 -> 알고리즘에 따라 다름
                outH = inH;
                outW = inW;
                // 출력 이미지 할당
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                // ************* 진짜 영상처리 알고리즘 구현*************
                // out = (in-low) / (high - low) *255
                var low=inImage[0][0], high = inImage[0][0];
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        if (inImage[i][k] < low) low = inImage[i][k];
                        if (inImage[i][k] > high) high = inImage[i][k];
                    }
                }
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        var out = (inImage[i][k]-low) / (high - low) *255.0
                        outImage[i][k] = parseInt(out);
                    }
                }
                // *****************************************
                displayImage();
            }
            function endIn_image() {
                // (중요!) 출력 영상의 크기를 결정 -> 알고리즘에 따라 다름
                outH = inH;
                outW = inW;
                // 출력 이미지 할당
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                // ************* 진짜 영상처리 알고리즘 구현*************
                // out = (in-low) / (high - low) *255
                var low=inImage[0][0], high = inImage[0][0];
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        if (inImage[i][k] < low) low = inImage[i][k];
                        if (inImage[i][k] > high) high = inImage[i][k];
                    }
                }
                low +=50;
                high -= 50;
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        var out = (inImage[i][k]-low) / (high - low) *255.0
                        outImage[i][k] = parseInt(out);
                    }
                }
                // *****************************************
                displayImage();
            }
            function histoEqual_image() {
                // (중요!) 출력 영상의 크기를 결정 -> 알고리즘에 따라 다름
                outH = inH;
                outW = inW;
                // 출력 이미지 할당
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                // ************* 진짜 영상처리 알고리즘 구현*************
                // 1 히스토그램 생성
                var histo = new Array(256);
                for(var i = 0; i <256; i++) //초기화
                    histo[i] = 0;
                for(i = 0; i < inH; i++) 
                    for(k = 0; k <inW; k++) 
                        histo[inImage[i][k]]++;
                // 2 누적 히스토그램 생성
                var sumHisto = new Array(256);
                for (var i = 0; i< 256; i++) sumHisto[i] = 0.0;
                var sumValue = 0;
                for (i = 0; i<256; i++){
                    sumValue += histo[i];
                    sumHisto[i] = sumValue;
                }
                // 3 정규화된 누적 합 생성
                // n[i] = sumHisto[i] * (1.0/(inH*inW) * 255.0)
                var n = new Array(256);
                for(var i = 0; i<256; i++) n[i]= 0.0;
                for(var i = 0; i<256; i++) n[i]= sumHisto[i] * (1.0/(inH*inW) * 255.0);
                
                // 최종
                for(i = 0; i < inH; i++)
                    for(k = 0; k <inW; k++)
                        outImage[i][k] = parseInt(n[inImage[i][k]]);

                 
                // *****************************************
                displayImage();
            }

            function embos_image() {
                // (중요!) 출력 영상의 크기를 결정 --> 알고리즘에 따름.
                outH = inH;
                outW = inW;
                // 출력 이미지 메모리 할당.
                outImage = new Array(outH);
                for(var i=0; i<outH; i++)
                    outImage[i] = new Array(outW);
                // ** 진짜 영상처리 알고리즘 구현 **
                // 짱! 중요
                var mask = [    [ -1.0 ,  0.0 ,  0.0 ], 
                                [  0.0 ,  0.0 ,  0.0 ], 
                                [  0.0 ,  0.0 ,  1.0 ]  ];
                // 임시 입력 배열 (입력배열+2) ==> 실수 처리
                var tmpInImage = new Array(inH+2);
                for(var i=0; i<inH+2; i++)
                    tmpInImage[i] = new Array(inW+2);
                // 임시 입력 초기화 (127) --> 평균값? --> 정말로 한줄도 못참는다. (가장자리 가까운 값으로..)
                for(var i=0; i<inH+2; i++) 
                    for (var k=0; k<inW+2; k++) 
                        tmpInImage[i][k] = 127.0;
                // 입력 배열 --> 임시 입력 배열의 가운데 쏙~ 
                for(var i=0; i<inH; i++) 
                    for (var k=0; k<inW; k++) 
                        tmpInImage[i+1][k+1] = inImage[i][k];

                // 임시 출력 배열(출력배열과 동일) ==> 실수
                var tmpOutImage = new Array(outH);
                for(var i=0; i<outH; i++)
                    tmpOutImage[i] = new Array(outW);
                //** 회선 연산 ** 마스크를 잡아서 전체를 긁으면서 계산하기...
                for(var i=0; i<inH; i++) {
                    for (var k=0; k<inW; k++) {
                        var S = 0.0;
                        for(var m=0; m<3; m++) 
                            for (var n=0; n<3; n++) 
                                S += tmpInImage[i+m][k+n] * mask[m][n];
                        
                        tmpOutImage[i][k] = S;
                    }
                }
                // 후처리 : 마스크의 합계가 0일 경우.... (예외 있음)
                for (var i=0; i<outH; i++)
                    for (var k=0; k<outW; k++)
                        tmpOutImage[i][k] += 127.0;
                // 임시 출력 배열 --> 출력 배열
                for (var i=0; i<outH; i++)
                    for (var k=0; k<outW; k++)
                        outImage[i][k] = parseInt(tmpOutImage[i][k]);
                // *******************************
                displayImage();
            }
            function vertical_image() {
                // (중요!) 출력 영상의 크기를 결정 --> 알고리즘에 따름.
                outH = inH;
                outW = inW;
                // 출력 이미지 메모리 할당.
                outImage = new Array(outH);
                for(var i=0; i<outH; i++)
                    outImage[i] = new Array(outW);
                // ** 진짜 영상처리 알고리즘 구현 **
                // 짱! 중요
                var mask = [    [  0.0 ,  0.0 ,  0.0 ], 
                                [ -1.0 ,  1.0 ,  0.0 ], 
                                [  0.0 ,  0.0 ,  0.0 ]  ];
                // 임시 입력 배열 (입력배열+2) ==> 실수 처리
                var tmpInImage = new Array(inH+2);
                for(var i=0; i<inH+2; i++)
                    tmpInImage[i] = new Array(inW+2);
                // 임시 입력 초기화 (127) --> 평균값? --> 정말로 한줄도 못참는다. (가장자리 가까운 값으로..)
                for(var i=0; i<inH+2; i++) 
                    for (var k=0; k<inW+2; k++) 
                        tmpInImage[i][k] = 127.0;
                // 입력 배열 --> 임시 입력 배열의 가운데 쏙~ 
                for(var i=0; i<inH; i++) 
                    for (var k=0; k<inW; k++) 
                        tmpInImage[i+1][k+1] = inImage[i][k];

                // 임시 출력 배열(출력배열과 동일) ==> 실수
                var tmpOutImage = new Array(outH);
                for(var i=0; i<outH; i++)
                    tmpOutImage[i] = new Array(outW);
                //** 회선 연산 ** 마스크를 잡아서 전체를 긁으면서 계산하기...
                for(var i=0; i<inH; i++) {
                    for (var k=0; k<inW; k++) {
                        var S = 0.0;
                        for(var m=0; m<3; m++) 
                            for (var n=0; n<3; n++) 
                                S += tmpInImage[i+m][k+n] * mask[m][n];
                        
                        tmpOutImage[i][k] = S;
                    }
                }
               
                // 임시 출력 배열 --> 출력 배열
                for (var i=0; i<outH; i++)
                    for (var k=0; k<outW; k++)
                        outImage[i][k] = parseInt(tmpOutImage[i][k]);
                // *******************************
                displayImage();
            }
            function blur_image() {
                // (중요!) 출력 영상의 크기를 결정 --> 알고리즘에 따름.
                outH = inH;
                outW = inW;
                // 출력 이미지 메모리 할당.
                outImage = new Array(outH);
                for(var i=0; i<outH; i++)
                    outImage[i] = new Array(outW);
                // ** 진짜 영상처리 알고리즘 구현 **
                // 짱! 중요
                var mask = [    [ 1/9, 1/9, 1/9 ], 
                                [  1/9, 1/9, 1/9 ], 
                                [  1/9, 1/9, 1/9 ]  ];
                // 임시 입력 배열 (입력배열+2) ==> 실수 처리
                var tmpInImage = new Array(inH+2);
                for(var i=0; i<inH+2; i++)
                    tmpInImage[i] = new Array(inW+2);
                // 임시 입력 초기화 (127) --> 평균값? --> 정말로 한줄도 못참는다. (가장자리 가까운 값으로..)
                for(var i=0; i<inH+2; i++) 
                    for (var k=0; k<inW+2; k++) 
                        tmpInImage[i][k] = 127.0;
                // 입력 배열 --> 임시 입력 배열의 가운데 쏙~ 
                for(var i=0; i<inH; i++) 
                    for (var k=0; k<inW; k++) 
                        tmpInImage[i+1][k+1] = inImage[i][k];

                // 임시 출력 배열(출력배열과 동일) ==> 실수
                var tmpOutImage = new Array(outH);
                for(var i=0; i<outH; i++)
                    tmpOutImage[i] = new Array(outW);
                //** 회선 연산 ** 마스크를 잡아서 전체를 긁으면서 계산하기...
                for(var i=0; i<inH; i++) {
                    for (var k=0; k<inW; k++) {
                        var S = 0.0;
                        for(var m=0; m<3; m++) 
                            for (var n=0; n<3; n++) 
                                S += tmpInImage[i+m][k+n] * mask[m][n];
                        
                        tmpOutImage[i][k] = S;
                    }
                }
                // 후처리 : 마스크의 합계가 0일 경우.... (예외 있음)
                // for (var i=0; i<outH; i++)
                //     for (var k=0; k<outW; k++)
                //         tmpOutImage[i][k] += 127.0;
                // 임시 출력 배열 --> 출력 배열
                for (var i=0; i<outH; i++)
                    for (var k=0; k<outW; k++)
                        outImage[i][k] = parseInt(tmpOutImage[i][k]);
                // *******************************
                displayImage();
            }

            function edge_image() {
                // (중요!) 출력 영상의 크기를 결정 --> 알고리즘에 따름.
                outH = inH;
                outW = inW;
                // 출력 이미지 메모리 할당.
                outImage = new Array(outH);
                for(var i=0; i<outH; i++)
                    outImage[i] = new Array(outW);
                // ** 진짜 영상처리 알고리즘 구현 **
                // 짱! 중요
                var mask = [    [ 0.0 ,  -1.0 ,  0.0 ], 
                                [  -1.0 ,  2.0 ,  0.0 ], 
                                [  0.0 ,  0.0 ,  0.0 ]  ];
                // 임시 입력 배열 (입력배열+2) ==> 실수 처리
                var tmpInImage = new Array(inH+2);
                for(var i=0; i<inH+2; i++)
                    tmpInImage[i] = new Array(inW+2);
                // 임시 입력 초기화 (127) --> 평균값? --> 정말로 한줄도 못참는다. (가장자리 가까운 값으로..)
                for(var i=0; i<inH+2; i++) 
                    for (var k=0; k<inW+2; k++) 
                        tmpInImage[i][k] = 127.0;
                // 입력 배열 --> 임시 입력 배열의 가운데 쏙~ 
                for(var i=0; i<inH; i++) 
                    for (var k=0; k<inW; k++) 
                        tmpInImage[i+1][k+1] = inImage[i][k];

                // 임시 출력 배열(출력배열과 동일) ==> 실수
                var tmpOutImage = new Array(outH);
                for(var i=0; i<outH; i++)
                    tmpOutImage[i] = new Array(outW);
                //** 회선 연산 ** 마스크를 잡아서 전체를 긁으면서 계산하기...
                for(var i=0; i<inH; i++) {
                    for (var k=0; k<inW; k++) {
                        var S = 0.0;
                        for(var m=0; m<3; m++) 
                            for (var n=0; n<3; n++) 
                                S += tmpInImage[i+m][k+n] * mask[m][n];
                        
                        tmpOutImage[i][k] = S;
                    }
                }
                // 후처리 : 마스크의 합계가 0일 경우.... (예외 있음)
                // for (var i=0; i<outH; i++)
                //     for (var k=0; k<outW; k++)
                //         tmpOutImage[i][k] += 127.0;
                // 임시 출력 배열 --> 출력 배열
                for (var i=0; i<outH; i++)
                    for (var k=0; k<outW; k++)
                        outImage[i][k] = parseInt(tmpOutImage[i][k]);
                // *******************************
                displayImage();
            }

            function laplacian_image() {
                // (중요!) 출력 영상의 크기를 결정 --> 알고리즘에 따름.
                outH = inH;
                outW = inW;
                // 출력 이미지 메모리 할당.
                outImage = new Array(outH);
                for(var i=0; i<outH; i++)
                    outImage[i] = new Array(outW);
                // ** 진짜 영상처리 알고리즘 구현 **
                // 짱! 중요
                var mask = [    [  0.0 ,  1.0 ,  0.0 ], 
                                [  1.0 ,  -4.0 ,  1.0 ], 
                                [  0.0 ,  1.0 ,  0.0 ]  ];
                // 임시 입력 배열 (입력배열+2) ==> 실수 처리
                var tmpInImage = new Array(inH+2);
                for(var i=0; i<inH+2; i++)
                    tmpInImage[i] = new Array(inW+2);
                // 임시 입력 초기화 (127) --> 평균값? --> 정말로 한줄도 못참는다. (가장자리 가까운 값으로..)
                for(var i=0; i<inH+2; i++) 
                    for (var k=0; k<inW+2; k++) 
                        tmpInImage[i][k] = 127.0;
                // 입력 배열 --> 임시 입력 배열의 가운데 쏙~ 
                for(var i=0; i<inH; i++) 
                    for (var k=0; k<inW; k++) 
                        tmpInImage[i+1][k+1] = inImage[i][k];

                // 임시 출력 배열(출력배열과 동일) ==> 실수
                var tmpOutImage = new Array(outH);
                for(var i=0; i<outH; i++)
                    tmpOutImage[i] = new Array(outW);
                //** 회선 연산 ** 마스크를 잡아서 전체를 긁으면서 계산하기...
                for(var i=0; i<inH; i++) {
                    for (var k=0; k<inW; k++) {
                        var S = 0.0;
                        for(var m=0; m<3; m++) 
                            for (var n=0; n<3; n++) 
                                S += tmpInImage[i+m][k+n] * mask[m][n];
                        
                        tmpOutImage[i][k] = S;
                    }
                }
                // 후처리 : 마스크의 합계가 0일 경우.... (예외 있음)
                // for (var i=0; i<outH; i++)
                //     for (var k=0; k<outW; k++)
                //         tmpOutImage[i][k] += 127.0;
                // 임시 출력 배열 --> 출력 배열
                for (var i=0; i<outH; i++)
                    for (var k=0; k<outW; k++)
                        outImage[i][k] = parseInt(tmpOutImage[i][k]);
                // *******************************
                displayImage();
            }
            function rotate_image() {
                // (중요!) 출력 영상의 크기를 결정 -> 알고리즘에 따라 다름
                outH = inH;
                outW = inW;
                // 출력 이미지 할당
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++)
                    outImage[i] = new Array(outW);
                
                // ** 진짜 영상처리 알고리즘 구현
                var angle = parseInt(prompt("각도", 45));
                angle = angle *Math.PI/ 180;
                // 공식 
                // new_i = cos*old_i -sin*old_k 
                // new_k = sin*old_i + cos*old_k
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        var new_i = parseInt(Math.cos(angle) * i - Math.sin(angle) * k);
                        var new_k = parseInt(Math.sin(angle) * i + Math.cos(angle) * k);
                        if(((0 <= new_i) && (new_i < outH)) && ((0 <= new_k) && (new_k < outW)))
                        outImage[new_i][new_k] = inImage[i][k];
                    }
                }
                // **************************
                displayImage();
            }
            function rotate2_image() {
                // (중요!) 출력 영상의 크기를 결정 -> 알고리즘에 따라 다름
                outH = inH;
                outW = inW;
                // 출력 이미지 할당
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++)
                    outImage[i] = new Array(outW);
                
                // ** 진짜 영상처리 알고리즘 구현
                var angle = parseInt(prompt("각도", 45));
                angle = angle *Math.PI/ 180;

                var cx = parseInt(inH/2);
                var cy = parseInt(inW/2);
                // 공식 
                // new_i = cos*(old_i-cx) - sin*(old_k-cy) +cx 
                // new_k = sin*(old_i-cx) + cos*(old_k-cy) +cy
                for(i = 0; i < outH; i++) {
                    for(k = 0; k <outW; k++) {
                        var old_i = parseInt(Math.cos(angle) * (i-cx) + Math.sin(angle) * (k-cy) +cx);
                        var old_k = parseInt(-Math.sin(angle) * (i-cx) + Math.cos(angle) * (k-cy) +cy);
                        if(((0 <= old_i) && (old_i < inH)) && ((0 <= old_k) && (old_k < inW)))
                        outImage[i][k] = inImage[old_i][old_k];
                    }
                }
                // **************************
                displayImage();
            }
            function zoomOut_image() {
                // (중요!) 출력 영상의 크기를 결정 -> 알고리즘에 따라 다름
                var scale = parseInt(prompt("축소배율", 2))                
                outH = parseInt(inH / scale);
                outW = parseInt(inW / scale);
                // 출력 이미지 할당
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                // 캔버스 크기 변경
                outCanvas.height = outH;
                outCanvas.width = outW;
                // ** 진짜 영상처리 알고리즘 구현

                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        outImage[parseInt(i/scale)][parseInt(k/scale)] = inImage[i][k];
                    }
                }
                // **************************
                displayImage();
            }
            function zoomIn_image() {
                // (중요!) 출력 영상의 크기를 결정 -> 알고리즘에 따라 다름
                var scale = parseInt(prompt("확대 배율", 2))                
                outH = parseInt(inH * scale);
                outW = parseInt(inW * scale);
                // 출력 이미지 할당
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                // 캔버스 크기 변경
                outCanvas.height = outH;
                outCanvas.width = outW;
                // ** 진짜 영상처리 알고리즘 구현

                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        outImage[parseInt(i*scale)][parseInt(k*scale)] = inImage[i][k];
                        outImage[parseInt(i*scale+scale-1)][parseInt(k*scale)] = inImage[i][k];
                        outImage[parseInt(i*scale)][parseInt(k*scale+scale-1)] = inImage[i][k];
                        outImage[parseInt(i*scale+scale-1)][parseInt(k*scale+scale-1)] = inImage[i][k];
                    }
                }
                // **************************
                displayImage();
            }
            function zoomIn2_image() {
                // (중요!) 출력 영상의 크기를 결정 -> 알고리즘에 따라 다름
                var scale = parseInt(prompt("확대 배율", 2))                
                outH = parseInt(inH * scale);
                outW = parseInt(inW * scale);
                // 출력 이미지 할당
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                // 캔버스 크기 변경
                outCanvas.height = outH;
                outCanvas.width = outW;
                // ** 진짜 영상처리 알고리즘 구현

                for(i = 0; i < outH; i++) {
                    for(k = 0; k <outW; k++) {
                        outImage[i][k] = inImage[parseInt(i/scale)][parseInt(k/scale)];
                    }
                }
                // **************************
                displayImage();
            }
            function bw_image() {
                // (중요!) 출력 영상의 크기를 결정 -> 알고리즘에 따라 다름
                
                outH = inH;
                outW = inW;
                // 출력 이미지 할당
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                // ** 진짜 영상처리 알고리즘 구현
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        if (inImage[i][k] <= 127) outImage[i][k] = 0;
                        else outImage[i][k] = 255
                    }
                }
                // **************************
                displayImage();
            }
            function bw2_image() {
                // (중요!) 출력 영상의 크기를 결정 -> 알고리즘에 따라 다름
                var avgValue, hapValue = 0;
                outH = inH;
                outW = inW;
                // 출력 이미지 할당
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        hapValue += inImage[i][k];
                    }
                }
                avgValue = hapValue / (inH * inW);
                // ** 진짜 영상처리 알고리즘 구현
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        if (inImage[i][k] <= avgValue) outImage[i][k] = 0;
                        else outImage[i][k] = 255
                    }
                }
                // **************************
                displayImage();
            }
            function bw3_image() {
                // (중요!) 출력 영상의 크기를 결정 -> 알고리즘에 따라 다름
                var mid = 0;
                var arr = [];
                outH = inH;
                outW = inW;
                // 출력 이미지 할당
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        // arr[index++] = inImage[i][k];
                        arr.push(inImage[i][k]);
                    }
                }

                arr.sort(function(a, b)  {
                    return a - b;
                });

                console.log(arr);
                console.log(arr[0]);
                // ** 진짜 영상처리 알고리즘 구현
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        if (inImage[i][k] <= arr[arr.length/2-1]) outImage[i][k] = 0;
                        else outImage[i][k] = 255
                    }
                }
                // **************************
                displayImage();
            }

            function add_image() {
                // (중요!) 출력 영상의 크기를 결정 -> 알고리즘에 따라 다름
                outH = inH;
                outW = inW;
                // 출력 이미지 할당
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                // ** 진짜 영상처리 알고리즘 구현
                var value= parseInt(prompt("값", 50));
                if(!value||!Number.isInteger(value)) {alert('취소 버튼 or 잘못된 입력으로 취도됨'); return 0;}
                // value에 아무것도 입력 안하거나 취소, 숫자가 아닌값 들어가면 
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        if(inImage[i][k] + value < 0) outImage[i][k] = 0;
                        else if(inImage[i][k] + value > 256) outImage[i][k] = 255;
                        else outImage[i][k] = inImage[i][k] + value;
                    }
                }
                // **************************
                displayImage();
            }
            function reverse_image() {
                // (중요!) 출력 영상의 크기를 결정 --> 알고리즘에 따름.
                outH = inH;
                outW = inW;
                // 출력 이미지 메모리 할당.
                outImage = new Array(outH);
                for(var i=0; i<outH; i++)
                    outImage[i] = new Array(outW);
                // ** 진짜 영상처리 알고리즘 구현 **
                for(var i=0; i<inH; i++) {
                    for (var k=0; k<inW; k++) {
                        outImage[i][k] = 255 - inImage[i][k];
                    }
                }
                // *******************************
                displayImage();
            }
            
            function mirror_image() {   
                outH = inH;
                outW = inW;
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                // ** 진짜 영상처리 알고리즘 구현
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        outImage[i][inW-k-1] = inImage[i][k];
                    }
                }
                displayImage();
            }
            function vertical_flip() {   
                outH = inH;
                outW = inW;
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                // ** 진짜 영상처리 알고리즘 구현
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        outImage[inH-i-1][k] = inImage[i][k];
                    }
                }
                displayImage();
            }
            function rotate_90_degrees() {   
                outH = inH;
                outW = inW;
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                // ** 진짜 영상처리 알고리즘 구현
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        outImage[Math.abs(k-(inH-1))][i] = inImage[i][k];
                    }
                }
                displayImage();
            }
            function rotate_180_degrees() {   
                outH = inH;
                outW = inW;
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                // ** 진짜 영상처리 알고리즘 구현
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        outImage[Math.abs(i-(inH-1))][Math.abs(k-(inW-1))] = inImage[i][k];
                    }
                }
                displayImage();
            }
            function rotate_270_degrees() {   
                outH = inH;
                outW = inW;
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                // ** 진짜 영상처리 알고리즘 구현
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        outImage[k][Math.abs(i-(inH-1))] = inImage[i][k];
                    }
                }
                displayImage();
            }
            function black_or_white() {   
                outH = inH;
                outW = inW;
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                // ** 진짜 영상처리 알고리즘 구현
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        if(inImage[i][k] < 128) outImage[i][k] = 0;
                        else outImage[i][k] = 255;
                        // outImage[i][k] = 0;
                    }
                }
                displayImage();
            }
            function sharpening() {   
                outH = inH;
                outW = inW;
                outImage = new Array(outH);
                for(var i = 0; i<outH; i++) {
                    outImage[i] = new Array(outW);
                }
                // ** 진짜 영상처리 알고리즘 구현
                for(i = 0; i < inH; i++) {
                    for(k = 0; k <inW; k++) {
                        if(inImage[i][k] < 40) outImage[i][k] = 0;
                        else outImage[i][k] = inImage[i][k];

                    }
                }
                displayImage();
            }
            
            var mark, pray, hover1, hover2;
            function chg(){
            mark = document.getElementById('mark');
            pray = document.getElementById('pray');
            hover1 = document.getElementById('lena');
            hover2 = document.getElementById('lenaExample');
            mark.classList.toggle('show');
            mark.classList.toggle('hide');
            pray.classList.toggle('show');
            pray.classList.toggle('hide');
            hover1.classList.toggle('stophv');
            hover2.classList.toggle('stophv');
            }
            
        </script>

    </HEAD>

    <BODY onload="init()">
        <h1 class="title">📽영상처리 알고리즘📽 </h1>
        <div>
            <img id="lena"src="https://www.researchgate.net/profile/Naison-Gasela/publication/237054247/figure/fig2/AS:299436317134849@1448402589122/Lena-original-gray.png" alt="lena">
            <span id="mark" class="show" onclick="chg()">👉→</span>
            <span id="pray" class="hide" onclick="chg()">🙏🙏</span>
            <img id="lenaExample"src="https://i.stack.imgur.com/z89Ej.png" alt="lena_example">

        </div>
        <form>
            <div class="container">
                <canvas id="inCanvas"></canvas>
                <span class="arrow">→</span>
                <canvas id="outCanvas"></canvas><br/>
            </div>
            
            <input type="file" id="inFile" onchange="openRawImage()"/><br/>
            <select name="pixel" id="" onchange="selectAlgo(this.form.pixel)">
                <option value="0">알고리즘을 선택하세요</option>
                <optgroup label="화소점 처리">
                    <option value="100">동일 영상</option>
                    <option value="101">밝게 / 어둡게</option>
                    <option value="102">반전</option>
                    <option value="103">좌우 반전</option>
                    <option value="104">상하 반전</option>
                    <option value="105">90도 회전</option>
                    <option value="106">180도 회전</option>
                    <option value="107">270도 회전</option>
                    <option value="108">흑백</option>
                    <option value="109">선명하게</option>

                    <option value="110">127</option>
                    <option value="111">평균</option>
                    <option value="112">중위수</option>
                
                <optgroup label="기하학 처리">
                    <option value="200">축소</option>
                    <option value="201">확대</option>
                    <option value="202">확대2</option>
                    <option value="210">회전</option>
                    <option value="211">회전(중앙백, 워딩)</option>

                <optgroup label="화소영역 처리">
                    <option value="300">엠보싱</option>
                    <option value="301">블러링</option>
                    <option value="302">운곽선 추출</option>
                    <option value="303">라플라시안 앳지</option>
                    <option value="304">수직검출</option>
                </optgroup>
                <optgroup label="히스토그램 처리">
                    <option value="400">히스토그램 스트레칭(명암대비)</option>
                    <option value="401">앤드인 탐색</option>
                    <option value="402">히스토그램 평활화</option>
                </optgroup>
                
            </select><br/>
        </form>
        <div class="bottom">
            <hr>
            <p>Special thanks to <a href="https://ko.wikipedia.org/wiki/%EB%A0%88%EB%82%98_(%EC%9D%B4%EB%AF%B8%EC%A7%80)" target="_blank">lena</a></p>
        </div>
        
    </BODY>
</HTML>